# XML Path Language

**XML Xtensible markup lenguage.** Sirvio para definir interfaces, es un lenguaje de nodos o etiquetas.
Una técnica para extraer datos de allí es Xpath.

>*XPath es a HTML, lo que las expresiones regulares son a texto, ambas se utilizan para buscar patrones.*

Es decir, Xpath es un lenguaje de patrones, expresiones que me permitirá extraer datos de un HTML. Puntualmente sirve para apuntar a partes de un documento XML.

[XPath cheatsheet](https://data-lessons.github.io/library-webscraping-DEPRECATED/extras/xpath-cheatsheet.md.pdf)

## Tipos de nodos de XPath

Un nodo es lo mismo que la etiqueta y su contenido. Un nodo puede contener a otros nodos.

En otras palabras, Xpath nos permitirá navegar en los diferentes niveles de profundidad deseados con el fin extraer información. Para describir los nodos y relaciones con Xpath se usan una
sintaxis de ejes.

[Toscrape](http://toscrape.com/) es un sandbox para practicar

## Expresiones en Xpath

Para escribir expresiones se usa ```$x('')```. Entre las comillas se escriben las expresiones que tienen diferentes símbolos que tienen una utilidad.

Se describe la utilidad de cada expresión.
- ```/``` hace referencia a la raíz, o a un salto entre nodos. Ej.: ```/html/body``` muestra todo lo que hay dentro del body de html

- ```//``` sirve para acceder a todos los nodos con la etiqueta seleccionada. Ej.: ```[*//span](//span)``` muestra todas las etiquetas span*

- ```..``` sirve para acceder a los nodos padre de la etiqueta tag. Ej.: ```//span/..``` accede a todos los nodos padre de span

- ```.``` hace referencia al nodo actual. Ej.: ```//span/.``` es equivalent a ```//span```

- ```@``` sirve para traer los atributos. Ej.: ```//div/@class``` nos da las clases de todos los divs

## Predicados en XPath

Empleamos los predicados para encontrar la información deseada. El predicado se coloca dentro de corchetes: ```[predicado]```

Predicados:
- ```n``` hace referencia al n elemento de la lista.
- ```last()``` hace referencia al último elemento de la lista.
- ```@atribute_name``` trae todos los nodos que contienen este atributo
- ```@atribute_name=" "```  trae todos los nodos que contengan el atributo especificado, incluso el value de este atributo.

Ejemplo de [Books to scrape](http://books.toscrape.com/):
```python
# Para extraer solo uno de los div del div container usamos un predicado

$x('/html/body/div/div[1]')
# Devuelve
[div.row.header-box]

$x('//span[@class="text"]/text()').map(x=>x.wholeText)
# Devuelve
(10) ["“The world as we have created it is a process of o…cannot be changed without changing our thinking.”", "“It is our choices, Harry, that show what we truly are, far more than our abilities.”", "“There are only two ways to live your life. One is… The other is as though everything is a miracle.”", "“The person, be it gentleman or lady, who has not …ure in a good novel, must be intolerably stupid.”", "“Imperfection is beauty, madness is genius and it'…be absolutely ridiculous than absolutely boring.”", "“Try not to become a man of success. Rather become a man of value.”", "“It is better to be hated for what you are than to be loved for what you are not.”", "“I have not failed. I've just found 10,000 ways that won't work.”", "“A woman is like a tea bag; you never know how strong it is until it's in hot water.”", "“A day without sunshine is like, you know, night.”"]
```

### Operadores con XPath

Hay una forma de filtrar más avanzada y es con operadores lógicos. Cabe notar que los operadores se están usando dentro del predicado.

Operadores lógicos en Xpath :

- !=
- <>
- and
- or
- not

Ejemplo de [Books to scrape](http://books.toscrape.com/):
```python
$x('//span[@class!="text"]') // todos los span que tenga una clase distinta de "text"

$x('/html/body/div/div[position()=1]') // trae los elementos en la posicion 1

$x('/html/body/div/div[position()>1]') // trae todos los elementos que se encuentran despues de la posicion 1

$x('//span[@class="text" and @class="tag-item"]') // trae los elementos que tengan como clase a "text" Y a "tag-item"

$x('//span[@class="text" or @class="tag-item"]') // trae los elementos que tengan como clase a "text" O a "tag-item"

$x('//span[not(@class)]') // trae todos los span que NO tengan una clase
```

## Wildcards (comodines)

- ```$x('/')``` trae todo el documento porque representa la raíz de nuestro el html
- ```$x('/*')``` después de ```/``` pide que traiga todos los nodos que están debajo de ```/```
- ```$x('/html/*')``` trae todos los nodos que están inmediatamente después de html
- ```$x('//*')``` es la expresión para saltar todos los niveles y con el ```*``` en todas las direcciones. Trae todos los nodos y todos los atributos de estos nodos.
- ```$x('//span[@class="text]/@*')``` trae todos los span que tengan un atributo de clase “text”.
- ```$x('/html/body//div/@*')``` trae todos los atributos de todos los div que están después de body
- ```$x('//span[@class="text" and @itemprop="text"]/node()')``` trae todos los spam que tengan atributos clase “text” y itemprop “text”. Seguidamente trae todo lo dentro del nodo que cumpla dichas condiciones.
- ```node()``` a diferencia de ```*``` trae no solamente los nodos, sino también todo el contenido

## In-text search en XPath

Para buscar cadenas de caracteres especificas dentro de un texto.
- ```start-with(.“Texto a buscar”)```
- ```contains(., “Texto a buscar”)```
Nota: Debido a las versiones del lenguaje Xpath en los navegadores
las funciones end-with y matches no están disponibles, pero una vz en código python corren sin problemas.
- ```end-with(.,"texto")```
- ```matches(.,"texto")```: Sirve para hacer una búsqueda en el texto de un nodo que coincida con una expresión regular.

Ejemplo de [Books to scrape](http://books.toscrape.com/):
```python
$x('//small[@class="author" and starts-with(.,"A")]/text()').map(x => x.wholeText)
# Devuelve
(4) ["Albert Einstein", "Albert Einstein", "Albert Einstein", "André Gide"]

$x('//small[@class="author" and contains(., "g")]/text()').map(x => x.wholeText)
# Devuelve
["J.K. Rowling"]
```

## XPath axes

- ```self::div``` se abrevia con ```.``` y se refiere al mismo nodo o div en este caso
- ```child::div``` trae los hijos del div
- ```descendant::div``` trae todos los nodos que están en niveles inferiores
- ```descendant-or-self::div``` trae la unión entre los descendientes y el mismo nodo div